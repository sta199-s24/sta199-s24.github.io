{
  "hash": "5f6a7ebbd8d4be5ee14f582efdf79ed5",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Exam 1 review\"\nsubtitle: \"Lecture 9\"\ndate: \"February 13, 2024\"\nformat: \n  revealjs:\n    footer: \"[üîó sta199-s24.github.io](https://sta199-s24.github.io/) &nbsp;¬∑&nbsp; [‚ùì Ask on Ed](https://edstem.org/us/courses/50730)\"\neditor_options: \n  chunk_output_type: console\n---\n\n\n# Warm up\n\n\n::: {.cell}\n\n:::\n\n\n## While you wait for class to begin...\n\nQuestions for/about the exam?\n\n\n```{=html}\n<iframe allowfullscreen frameborder=\"0\" height=\"100%\" mozallowfullscreen style=\"min-width: 500px; min-height: 355px\" src=\"https://app.wooclap.com/STA199S24?from=status-bar?\" width=\"100%\"></iframe>\n```\n\n## Packages\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\nlibrary(openintro)\n```\n:::\n\n\n## Announcements\n\n-   Exam format / flow\n\n-   Academic dishonesty / Duke Community Standard\n\n# Type coercion\n\n## Explicit vs. implicit type coercion\n\n-   Explicit type coercion: You ask R to change the type of a variable\n\n-   Implicit type coercion: R changes / makes assumptions for you about the type of a variable without you asking for it\n\n    -   This happens because in a vector, you can't have multiple types of values\n\n## Vectors {.smaller}\n\n::: incremental\n-   A vector is a collection of values\n\n    -   Atomic vectors can only contain values of the same type\n\n    -   Lists can contain values of different types\n\n-   Why do we care?\n    Because each column of a data frame is a vector.\n:::\n\n. . .\n\n\n::: {.cell}\n\n```{.r .cell-code  code-line-numbers=\"|2|3|4\"}\ndf <- tibble(\n  x = c(1, 2, 3),          # numeric (double)\n  y = c(\"a\", \"b\", \"c\"),    # character\n  z = c(TRUE, FALSE, TRUE) # logical\n)\ndf\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 3 √ó 3\n      x y     z    \n  <dbl> <chr> <lgl>\n1     1 a     TRUE \n2     2 b     FALSE\n3     3 c     TRUE \n```\n\n\n:::\n:::\n\n\n## Explicit coercion\n\n‚úÖ From numeric to character\n\n\n::: {.cell}\n\n```{.r .cell-code  code-line-numbers=\"|2\"}\ndf |>\n  mutate(x_new = as.character(x))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 3 √ó 4\n      x y     z     x_new\n  <dbl> <chr> <lgl> <chr>\n1     1 a     TRUE  1    \n2     2 b     FALSE 2    \n3     3 c     TRUE  3    \n```\n\n\n:::\n:::\n\n\n## Explicit coercion\n\n‚ùå From character to numeric\n\n\n::: {.cell}\n\n```{.r .cell-code  code-line-numbers=\"|2\"}\ndf |>\n  mutate(y_new = as.numeric(y))\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning: There was 1 warning in `mutate()`.\n‚Ñπ In argument: `y_new = as.numeric(y)`.\nCaused by warning:\n! NAs introduced by coercion\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 3 √ó 4\n      x y     z     y_new\n  <dbl> <chr> <lgl> <dbl>\n1     1 a     TRUE     NA\n2     2 b     FALSE    NA\n3     3 c     TRUE     NA\n```\n\n\n:::\n:::\n\n\n## Implicit coercion\n\n::: question\nWhich of the column types were implicitly coerced?\n:::\n\n\n::: {.cell}\n\n```{.r .cell-code  code-line-numbers=\"|2|3\"}\ndf <- tibble(\n  w = c(1, 2, 3),\n  x = c(\"a\", \"b\", 4),\n  y = c(\"c\", \"d\", NA),\n  z = c(5, 6, NA),\n)\ndf\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 3 √ó 4\n      w x     y         z\n  <dbl> <chr> <chr> <dbl>\n1     1 a     c         5\n2     2 b     d         6\n3     3 4     <NA>     NA\n```\n\n\n:::\n:::\n\n\n## Collecting data {.smaller}\n\n::: question\nSuppose you conduct a survey and ask students their student ID number and number of credits they're taking this semester.\nWhat is the type of each variable?\n:::\n\n. . .\n\n\n::: {.cell}\n\n```{.r .cell-code  code-line-numbers=\"|2|3\"}\nsurvey_raw <- tibble(\n  student_id = c(273674, 298765, 287129, \"I don't remember\"),\n  n_credits = c(4, 4.5, \"I'm not sure yet\", \"2 - underloading\")\n)\nsurvey_raw\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 4 √ó 2\n  student_id       n_credits       \n  <chr>            <chr>           \n1 273674           4               \n2 298765           4.5             \n3 287129           I'm not sure yet\n4 I don't remember 2 - underloading\n```\n\n\n:::\n:::\n\n\n## Cleaning data {.smaller}\n\n\n::: {.cell}\n\n```{.r .cell-code  code-line-numbers=\"|2|3\"}\nsurvey <- survey_raw |>\n  mutate(\n    student_id = if_else(student_id == \"I don't remember\", NA, student_id),\n    n_credits = case_when(\n      n_credits == \"I'm not sure yet\" ~ NA,\n      n_credits == \"2 - underloading\" ~ \"2\",\n      .default = n_credits\n    ),\n    n_credits = as.numeric(n_credits)\n  )\nsurvey\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 4 √ó 2\n  student_id n_credits\n  <chr>          <dbl>\n1 273674           4  \n2 298765           4.5\n3 287129          NA  \n4 <NA>             2  \n```\n\n\n:::\n:::\n\n\n## Cleaning data -- alternative {.smaller}\n\n\n::: {.cell}\n\n```{.r .cell-code  code-line-numbers=\"|2|3\"}\nsurvey <- survey_raw |>\n  mutate(\n    student_id = parse_number(student_id),\n    n_credits = parse_number(n_credits)\n  )\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning: There were 2 warnings in `mutate()`.\nThe first warning was:\n‚Ñπ In argument: `student_id = parse_number(student_id)`.\nCaused by warning:\n! 1 parsing failure.\nrow col expected           actual\n  4  -- a number I don't remember\n‚Ñπ Run `dplyr::last_dplyr_warnings()` to see the 1 remaining warning.\n```\n\n\n:::\n\n```{.r .cell-code  code-line-numbers=\"|2|3\"}\nsurvey\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 4 √ó 2\n  student_id n_credits\n       <dbl>     <dbl>\n1     273674       4  \n2     298765       4.5\n3     287129      NA  \n4         NA       2  \n```\n\n\n:::\n:::\n\n\n## Recap: Type coercion\n\n::: incremental\n-   If variables in a data frame have multiple types of values, R will coerce them into a single type, which may or may not be what you want.\n\n-   If what R does by default is not what you want, you can use explicit coercion functions like `as.numeric()`, `as.character()`, etc. to turn them into the types you want them to be, which will generally also involve cleaning up the features of the data that caused the unwanted implicit coercion in the first place.\n:::\n\n# Aesthetic mappings\n\n## `openintro::loan50`\n\n\n::: {.cell}\n\n```{.r .cell-code}\nloan50 |>\n  select(annual_income, interest_rate, homeownership)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 50 √ó 3\n   annual_income interest_rate homeownership\n           <dbl>         <dbl> <fct>        \n 1         59000         10.9  rent         \n 2         60000          9.92 rent         \n 3         75000         26.3  mortgage     \n 4         75000          9.92 rent         \n 5        254000          9.43 mortgage     \n 6         67000          9.92 mortgage     \n 7         28800         17.1  rent         \n 8         80000          6.08 mortgage     \n 9         34000          7.97 rent         \n10         80000         12.6  mortgage     \n# ‚Ñπ 40 more rows\n```\n\n\n:::\n:::\n\n\n## Aesthetic mappings\n\n::: question\nWhat will the following code result in?\n:::\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(\n  loan50,\n  aes(x = annual_income, y = interest_rate, color = homeownership, shape = homeownership)\n) +\n  geom_point() +\n  scale_color_colorblind()\n```\n:::\n\n\n## Aesthetic mappings\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(\n  loan50,\n  aes(x = annual_income, y = interest_rate, color = homeownership, shape = homeownership)\n) +\n  geom_point() +\n  scale_color_colorblind()\n```\n\n::: {.cell-output-display}\n![](09-exam-1-review_files/figure-revealjs/unnamed-chunk-12-1.png){width=768}\n:::\n:::\n\n\n## Global mappings\n\n::: question\nWhat will the following code result in?\n:::\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(\n  loan50,\n  aes(x = annual_income, y = interest_rate, color = homeownership, shape = homeownership)\n) +\n  geom_point() +\n  geom_smooth(se = FALSE) +\n  scale_color_colorblind()\n```\n:::\n\n\n## Global mappings\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(\n  loan50,\n  aes(x = annual_income, y = interest_rate, color = homeownership, shape = homeownership)\n) +\n  geom_point() +\n  geom_smooth(se = FALSE) +\n  scale_color_colorblind()\n```\n\n::: {.cell-output-display}\n![](09-exam-1-review_files/figure-revealjs/unnamed-chunk-14-1.png){width=768}\n:::\n:::\n\n\n## Local mappings\n\n::: question\nWhat will the following code result in?\n:::\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(\n  loan50,\n  aes(x = annual_income, y = interest_rate)\n) +\n  geom_point(aes(color = homeownership)) +\n  geom_smooth(se = FALSE) +\n  scale_color_colorblind()\n```\n:::\n\n\n## Local mappings\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(\n  loan50,\n  aes(x = annual_income, y = interest_rate)\n) +\n  geom_point(aes(color = homeownership)) +\n  geom_smooth(se = FALSE) +\n  scale_color_colorblind()\n```\n\n::: {.cell-output-display}\n![](09-exam-1-review_files/figure-revealjs/unnamed-chunk-16-1.png){width=768}\n:::\n:::\n\n\n## Mapping vs. setting\n\n::: question\nWhat will the following code result in?\n:::\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(\n  loan50,\n  aes(x = annual_income, y = interest_rate)\n) +\n  geom_point(aes(color = homeownership)) +\n  geom_smooth(color = \"red\", se = FALSE) +\n  scale_color_colorblind()\n```\n:::\n\n\n## Mapping vs. setting\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(\n  loan50,\n  aes(x = annual_income, y = interest_rate)\n) +\n  geom_point(aes(color = homeownership)) +\n  geom_smooth(color = \"red\", se = FALSE) +\n  scale_color_colorblind()\n```\n\n::: {.cell-output-display}\n![](09-exam-1-review_files/figure-revealjs/unnamed-chunk-18-1.png){width=768}\n:::\n:::\n\n\n## Recap: Aesthetic mappings\n\n::: incremental\n-   Aesthetic mapping defined at the *global* level will be used by all `geom`s for which the aesthetic is defined.\n\n-   Aesthetic mapping defined at the *local* level will be used only by the `geom`s they're defined for.\n:::\n\n## Aside: Legends\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(\n  loan50,\n  aes(x = annual_income, y = interest_rate, color = homeownership, shape = homeownership)\n) +\n  geom_point() +\n  scale_color_colorblind()\n```\n\n::: {.cell-output-display}\n![](09-exam-1-review_files/figure-revealjs/unnamed-chunk-19-1.png){width=768}\n:::\n:::\n\n\n## Aside: Legends {.smaller}\n\n\n::: {.cell}\n\n```{.r .cell-code  code-line-numbers=\"|7\"}\nggplot(\n  loan50,\n  aes(x = annual_income, y = interest_rate, color = homeownership, shape = homeownership)\n) +\n  geom_point() +\n  scale_color_colorblind() +\n  labs(color = \"Home ownership\")\n```\n\n::: {.cell-output-display}\n![](09-exam-1-review_files/figure-revealjs/unnamed-chunk-20-1.png){width=768}\n:::\n:::\n\n\n## Aside: Legends {.smaller}\n\n\n::: {.cell}\n\n```{.r .cell-code  code-line-numbers=\"|8-9\"}\nggplot(\n  loan50,\n  aes(x = annual_income, y = interest_rate, color = homeownership, shape = homeownership)\n) +\n  geom_point() +\n  scale_color_colorblind() +\n  labs(\n    color = \"Home ownership\",\n    shape = \"Home ownership\"\n  )\n```\n\n::: {.cell-output-display}\n![](09-exam-1-review_files/figure-revealjs/unnamed-chunk-21-1.png){width=768}\n:::\n:::\n\n\n# Factors\n\n## Factors\n\n-   Factors are used for categorical variables -- variables that have a fixed and known set of possible values.\n\n-   They are also useful when you want to display character vectors in a non-alphabetical order.\n\n::: aside\nR4DS: <https://r4ds.hadley.nz/factors>.\n:::\n\n## Bar plot\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(loan50, aes(x = homeownership)) +\n  geom_bar()\n```\n\n::: {.cell-output-display}\n![](09-exam-1-review_files/figure-revealjs/unnamed-chunk-22-1.png){width=960}\n:::\n:::\n\n\n## Bar plot - reordered\n\n\n::: {.cell}\n\n```{.r .cell-code}\nloan50 |>\n  mutate(homeownership = fct_relevel(homeownership, \"mortgage\", \"rent\", \"own\")) |>\n  ggplot(aes(x = homeownership)) +\n  geom_bar()\n```\n\n::: {.cell-output-display}\n![](09-exam-1-review_files/figure-revealjs/unnamed-chunk-23-1.png){width=960}\n:::\n:::\n\n\n## Frequency table\n\n\n::: {.cell}\n\n```{.r .cell-code}\nloan50 |>\n  count(homeownership)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 3 √ó 2\n  homeownership     n\n  <fct>         <int>\n1 rent             21\n2 mortgage         26\n3 own               3\n```\n\n\n:::\n:::\n\n\n## Bar plot - reordered\n\n\n::: {.cell}\n\n```{.r .cell-code}\nloan50 |>\n  mutate(homeownership = fct_relevel(homeownership, \"own\", \"rent\", \"mortgage\")) |>\n  count(homeownership)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 3 √ó 2\n  homeownership     n\n  <fct>         <int>\n1 own               3\n2 rent             21\n3 mortgage         26\n```\n\n\n:::\n:::\n\n\n## Under the hood\n\n\n::: {.cell}\n\n```{.r .cell-code}\nclass(loan50$homeownership)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"factor\"\n```\n\n\n:::\n:::\n\n\n. . .\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntypeof(loan50$homeownership)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"integer\"\n```\n\n\n:::\n:::\n\n\n. . .\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlevels(loan50$homeownership)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"rent\"     \"mortgage\" \"own\"     \n```\n\n\n:::\n:::\n\n\n. . .\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstr(loan50$homeownership)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n Factor w/ 3 levels \"rent\",\"mortgage\",..: 1 1 2 1 2 2 1 2 1 2 ...\n```\n\n\n:::\n:::\n\n\n## Recap: Factors\n\n::: incremental\n-   The **forcats** package has a bunch of functions (that start with `fct_*()`) for dealing with factors and their levels: <https://forcats.tidyverse.org/reference/index.html>\n\n-   Factors and the order of their levels are relevant for displays (tables, plots) and they'll be relevant for modeling (later in the course)\n\n-   `factor` is a data **class**\n:::\n\n## Aside: `==`\n\n\n::: {.cell}\n\n```{.r .cell-code}\nloan50 |>\n  mutate(homeownership_new = if_else(homeownership == \"rent\", \"don't own\", homeownership)) |>\n  distinct(homeownership, homeownership_new)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 3 √ó 2\n  homeownership homeownership_new\n  <fct>         <chr>            \n1 rent          don't own        \n2 mortgage      mortgage         \n3 own           own              \n```\n\n\n:::\n:::\n\n\n## Aside: `|`\n\n\n::: {.cell}\n\n```{.r .cell-code}\nloan50 |>\n  mutate(homeownership_new = if_else(homeownership == \"rent\" | homeownership == \"mortgage\", \"don't own\", homeownership)) |>\n  distinct(homeownership, homeownership_new)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 3 √ó 2\n  homeownership homeownership_new\n  <fct>         <chr>            \n1 rent          don't own        \n2 mortgage      don't own        \n3 own           own              \n```\n\n\n:::\n:::\n\n\n## Aside: `|`\n\n\n::: {.cell}\n\n```{.r .cell-code}\nloan50 |>\n  mutate(homeownership_new = if_else(homeownership %in% c(\"rent\", \"mortgage\"), \"don't own\", homeownership)) |>\n  distinct(homeownership, homeownership_new)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 3 √ó 2\n  homeownership homeownership_new\n  <fct>         <chr>            \n1 rent          don't own        \n2 mortgage      don't own        \n3 own           own              \n```\n\n\n:::\n:::\n\n\n# Other questions?\n",
    "supporting": [
      "09-exam-1-review_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-after-body": [
        "\n<script>\n  // htmlwidgets need to know to resize themselves when slides are shown/hidden.\n  // Fire the \"slideenter\" event (handled by htmlwidgets.js) when the current\n  // slide changes (different for each slide format).\n  (function () {\n    // dispatch for htmlwidgets\n    function fireSlideEnter() {\n      const event = window.document.createEvent(\"Event\");\n      event.initEvent(\"slideenter\", true, true);\n      window.document.dispatchEvent(event);\n    }\n\n    function fireSlideChanged(previousSlide, currentSlide) {\n      fireSlideEnter();\n\n      // dispatch for shiny\n      if (window.jQuery) {\n        if (previousSlide) {\n          window.jQuery(previousSlide).trigger(\"hidden\");\n        }\n        if (currentSlide) {\n          window.jQuery(currentSlide).trigger(\"shown\");\n        }\n      }\n    }\n\n    // hookup for slidy\n    if (window.w3c_slidy) {\n      window.w3c_slidy.add_observer(function (slide_num) {\n        // slide_num starts at position 1\n        fireSlideChanged(null, w3c_slidy.slides[slide_num - 1]);\n      });\n    }\n\n  })();\n</script>\n\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}